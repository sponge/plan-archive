Welcome to id Software's Finger Service V1.5!

Name: John Carmack
Email: johnc@idsoftware.com
Description: Programmer
Project: Quake 3 Arena
Last Updated: 09/29/1999 11:02:38 (Central Standard Time)
-------------------------------------------------------------------------------
9/29/99
-------
I wrote this in answer to a question on the mac opengl programming
list, but it is of general enough interest to programmers that I am
repeating it here.

>You also mentioned display lists...  Can you explain what some of the
>major things that should be rendered using a display list are?  I see
>the importance of using them for characters (animation) and objects, but
>what about using them for the rest of the world, particles, and other
>things that are nifty.

This is not yet a big issue, although even pure software OpenGL's could
perform some optimizations with display lists that aren't possible with
vertex arrays.  With hardware geometry acceleration, it can be an honest
4x improvement in throughput.

The important point is that once geometry acceleration becomes a primary
target, practically everything will have to be rendered with display
lists, or you will run into a nasty case of Amdahl's law.

In a busy Q3 battle, the triangle count may be split roughly evenly
between character models and world geometry.  Going from an empty scene
to a pitched battle can result in a 50% performance drop if you are
triangle limited.  Not great, but livable.

If we kept the same ratios and designed for geometry acceleration with
all the static world geometry in display lists, then the empty scene
could have 4x the geometry and still be running the same speed.
However, current OpenGL display lists can't really accelerate high
quality skinned characters, so when an equal number of character
polygons was in scene and passed through normal direct rendering, the
performance would drop to 20% of the original.  Unacceptable.

So, either you would have to use significantly different polygon counts
in characters and the world, or some new API features would need to be
defined.  Nvidia has a skinning extension that gives some benefit, but
still requires a character to be broken up into one static list per
bone pair, instead of a single list for the entire character.

Rendering a few thousand particles or other procedurally generated
triangles directly isn't going to be a big issue, but the bulk of the
work is going to move towards static vertex data.

My advice for display lists is to use them for just raw
vertex/color/texcoord data, and keep your state changes done with
direct commands.  This allows you to still sort display lists to
minimze state changes, and prevents drivers from ever having to check
state internally.  Some hardware architectures can nicely encapsulate
all state changes in a single dma buffer, but register sharing among
different fields sometimes requires the driver to do manual masks,
negating much of the async display list benefits.  Texture swapping
also complicates state changes inside display lists.

You want to make the display lists as big as practical, but there is
a tradeoff betwen culling tightness and display list size.


9/28/99
-------
Ok, obviously we didn't get a release out in the middle of the month...

We are still hashing out the single player game, so it still isn't
immediately immenent.

* weapon switch animations at 20hz instead of 15hz
	cuts switch time from 600 msec to 450 msec
* initial spawn flag for single player
* finished new fog code
* fixed walking underwater friction problems
* autosprite2 now selects the longest axis to pivot on,
	and allows any texture mapping, not just unity
* fixed autosprite on entities
* fixed lurching during low timescale
* reduced machinegun damage
* set clamp mode on 2D pics
* take hostname off of single player connect
* remvoed dlighting on skies and solid lava
* fixed lower body twitch when copytobodyque with a motion
* always show your score in second box if not in first
* sarge as default model
* com_blood 0 option for no gibs and no blood on hits
* mouse click aborts cinematic
* show tourney scores in all games, add fraglimit
* removed tripple bunny-hop protection, it was too arbitrary and didn't
	accomplish it's goal
* pump event loop during level loading
* added pass count to shaderlist
* default to CGEN_IDENTITY / CGEN_IDENTITY_LIGHTING based on blendSrc
* optional simplified blendfuncs: blendfunc 
* new shader command: deformVertexes normal  
* new shader command: tcgen vector (    ) (    )
* fixed fog on alpha tested surfaces
* reduced com_maxfps to 85
* defined shaders for menu and console backgrounds
* reset players on clientinfo transitions
* windows icons
* fixed powerups on spinning barrels
* removed some latency from lightning endpoint
* fixed lightning bolt drawing too far
* removed color clamping from entity lighting
* moved all 2D drawing to shader pipeline
* r_printShaders tool
* moved dlighting into world node descent
* pause when menu is up in single player
* fixed double EV_FIRE_WEAPON
* r_singleShader optimization tool
* some renderer optimizations
* better multitexture collapsing

9/6/99
------

It looks like we are going to go to a skeletal model system.  Jim Dose of
Ritual had already started on an exporter from character studio, so we decided
to just meet in the middle.

I implemented the loading and rendering support this weekend and tested it
with a couple hand-inserted bones, so now we just need to write the glue
between character studio and the new .md4 format.

The new format is bone based, but it is NOT hierarchial.  Each vertex just has
an arbitrary weighted list of the bones that influence it.  Bones are just 4x3
matricies of floats.

A hierarchial skeleton has some advantages (angles instead of matricies, 
ability to do IK, etc), but this is a direct and simple replacement for our
existing infrastructure that doesn't require any cached state per model
instance.

A single .md4 file holds multiple level of detail surface sets, which all
share the same bone frames.

In use, it is exactly like the existing models (interpolate between two
frame numbers), it just saves a huge amount of space.

I used perl to generate my test data, and it was definately faster than having
a separate msdev open and doing it in C.

I am trying to use parenthesis on all perl functions, but when I type "print",
my fingers seem to have a flashback to applesoft basic fifteen years ago, and
I wind up with bare quotes on prints and parens on everything else...

Does anyone know if there is an existing msdev syntax coloring file for perl?
(no, I don't want to switch to a different editor!)

* md4 model loading and displaying
* removed clip models from cgame, use renderer models instead
* fixed mover pushing again
* fixed bug with culling of mirrors made of multiple faces
* fixed quad on spinning machinegun
* surfaceparm alphashadow
	This causes q3map -light to check individual texture 
	pixels on transparant surfaces for light shadowing
	instead of making the entire surface either cast or
	not cast shadows


9/2/99
------

I have been getting a lot of requests for commentary on two subjects lately:

Nvidia's new geometry accelerated card with the funny name.

It is fast.  Very, very fast.  It has the highest fill rate of any card we
have ever tested, has improved image quality over TNT2, and it gives timedemo
scores 40% faster than the next closest score with extremely raw beta drivers.

The throughput will definately improve even more as their drivers mature.

For max framerates in OpenGL games, this card is going to be very hard to
beat.

Q3's target of about 10,000 triangles a frame doesn't stress this card at
all.  If you want more polygons out of Q3, you can do:

r_lodBias -2			// don't use lower detail models
r_subdivisions 1 		// lots more triangles in curves
r_lodCurveError 10000	// don't drop curve rows for a long time

I haven't looked at the stencil shadow stuff in a long time, but it gives
the largest increase in triangle use (and a lot of fill rate as well):

cg_shadows	2		// turn on stencil shadows
				// (if you have a stencil buffer)



Apple's new G4 systems.

The initial systems are just G4 processors in basically the same systems as
the current G3.  There will be some speedup in the normal C code from the
faster floating point unit, and the Apple OpenGL has AltiVec optimizations,
so framerates will improve somewhat.  The limiting factor is going to be
the fill rate on the rage128 and the bandwidth of the 66mhz pci bus and
processor to main memory writes.

The later G4 systems with the new memory controller and AGP will have
better performance, but probably still limited by the new 3D card.

After Apple gets all their driver tuning done, it will be interesting to try
running timedemos at low resolution to factor the fill rate out.  Apple has
a shot at having the best non-geometry accelerated throughput, but it will
still be tough to overcome a K7 with an extra hundred or so mhz.

On a purely technical note, AltiVec is more flexible for computation than
intel or AMD's extensions (trinary ops), but intel style write combining is
better for filling command buffers than the G4's memory streaming operations.



9/1/99
------
I have been working on our memory footprint for the past couple days.  There
are two types of paging that occur: 

One time only paging that eventually settles down after you have run around
the entire