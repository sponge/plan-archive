Welcome to id Software's Finger Service V1.5!

Name: John Carmack
Email: johnc@idsoftware.com
Description: Programmer
Project: Quake 3 Arena
Last Updated: 05/05/1999 04:14:55 (Central Standard Time)
-------------------------------------------------------------------------------
5/5/99
------
* client side predict item pickups
	running over items was one of the few
	remaining locally perceived signs of lag
* new pont-in-patch test code
* fixed pathname errors when mac users had
	slashes in their paths: "B/W mac". sigh.


5/4/99
------
* seeded random numbers differently on tourney restarts
* fixed events on initial snapshots
* removed g_maxentities configuration, set by G_ENTITY_BITS
* cl_motd 0 to allow never sending request packets
* fixed map cache clearing bug
* cg_drawFPS 1 for running fps counter in corner
* remove all teleport destination pads
* moved checkmap out of cgame
* moved time positioning out of cgame
* made usercmd overrun freeze in place instead of snapping back
* slightly increased shotgun spread
* protected against using a cleared clientinfo
* use snapped origin from players for linking to prevent
	slight prediction errors during player collisions


4/30/99
-------
I put together a document on optimizing OpenGL drivers for Q3 that
should be helpfull to the various linux 3D teams.

http://www.quake3arena.com/news/glopt.html


4/30/99
-------
* vmtest framework, q3asm work
* converted scene building to procedural style
	allows better error checking, better
	performance characteristics when interpreted,
	and is a setup stage for SMP optimizations in
	the renderer if I get around to it
* protected some potential div by 0 areas in cgame


4/29/99
-------
* rework versioning for architecture tracking
* use a seperate endpoint for address resolves on mac
* hide OTLook warnings if "developer" isn't set
* defered mac renderer scanning until after mode set so
	8 bit desktops don't confuse it
* global motd/update server
* fixed view model animations on models with custom anims

technical note:

Q3 can run networked player movement in either an asynchronous or
synchronous manner.  The default mode is to allow all client movement to be
done asynchronously with the servers advancement of time.

The primary reason is to allow player movement to be predicted on the client
side.  The primary drawback is that while your movement is smooth, the other
players that you see running around in the world move with a jerkiness that
is relative to their framerate and network connection quality.  It is NOT
necessarily relative to their ping - a player on a fast system with a clean
modem connection can move smoothly.  If you see a player stuttering around,
either they have a bad franerate, or the network connection between them and
the server or you and the server is poor.  The amount of stuttering is sort
of the sum of the dropped or variable packets on BOTH connections.

You can force Q3 to run all clients synchronously by setting
"g_synchronousClients 1" on the server.  This will make Q3 behave similar to
Q1 for networking.  All movement will be lagged except view angles, which are
still short-circuited immediately.

Some people claim to prefer synchronous movement when everyone had a very
good ping, but I don't personally think it is ever a play benefit.  It
makes leading players a bit easier, but I think the crisp movement control
of client side prediction is a much better tradeoff.

However, there is still a reason for using it:  recorded demos come out a
LOT smoother looking when running with sync.  Note that q3test does not
allow demo recording and playback, so this is just for future reference...


4/28/99
-------
* converted sound positioning away from callback method
* increased mac memory zone by 5 megs
* new memory allocator for temporary render use during init
* converted cmodel references to handles and range checked
* converted sound references to handles and range checked
* converted file references to handles and range checked

4/27/99
-------
* cgame converted to use local buffer based lerpTag for interpretation
* cgame converted to use local buffer based argv for interpretation
* new sound code to remove latency 
* added drop shadow to field characters and fixed scrolling
* fixed edge-of-bounce-pad misprediction error (server side)
* remove broken weapon-stay dmflag
* made menu gfx never picmip
* cheat protect r_lightmap
* clear sound buffer before any file IO
* use GetOSEvent instead of WaitNextEvent on mac when fullscreen
	removes hitches caused by other tasks and gives a
	performance boost
* continuous scoreboard / ping update when tab is down
* put version number on menu background
* fixed toggle cvar bug
* dim out behind floating menus


4/26/99
-------

One more addition to net cvars:

"cl_maxpackets" will restrict the maximum number of outgoing
packets to prevent client to server rate problems.  This does
not limit the client framerate.  This defaults to 20, which
might actually be a bit low.  You might try experimenting
with raising this to 40.

"cl_maxfps" still exists, but it will never need to be used
for networking reasons.


4/26/99
-------

Interpreting the lagometer (the graph in the lower right corner):

The upper graph (blue/yellow) slides one pixel for every rendered
frame.  Blue lines below the baseline mean that the frame is
interpolating between two valid snapshots.  Yellow lines above
the baseline mean the frame is extrapolating beyond the latest
valid time.  The length of the line is proportional to the time.

The lower graph (green/yellow/red) slides one pixel for every
received snapshot.  By default, snapshots come 20 times a second,
so if you are running >20 fps, the top graph will move faster, and
vice versa.  A red bar means the snapshot was dropped by the
network.  Green and yellow bars are properly received snapshots,
with the height of the bar proportional to the ping.  A yellow
bar indicates that the previous snapshot was intentionally
supressed to stay under the rate limit.

The upper graph indicates the consistancy of your connection.
Ideally, you should always have blue bars of only a pixel or two
in height.  If you are commonly getting big triangles of yellow
on the graph, your connection is inconsistant.

In a heavy firefight, it is normal for modem players to see yellow
bars in the bottom graph, which should return to green when the
action quiets down.  If you are getting several red bars visible,
you may want to look for a server that drops less packets.

There are a few tuning variables for people trying to optimize
their connection:

The most important one is "rate", which is what the connection
speed option in the menu sets.

We are fairly conservative with the values we set for the given
modem speeds: 2500 for 28.8, 3000 for 33, and 3500 for 56k.

You may actually be connecting faster than that, and modem
compression may be buying you something, so you might get a
better play experience by increasing the values slightly.

If you connect at 50000 bps, try a rate of 5000, etc.

I err on the conservative side, because too low of a rate will
only make the movement of other things in the world choppy, while
too high of a rate can cause huge amounts of lag.

Note that the optimal rate will be somewhat lower than a rate
for QW or Q2, because I now include the UDP packet header
length in the bandwidth estimate.

You can ask for a different number of snapshots by changing the
"snaps" variable, but there isn't a lot of benefit to that.
Dedicated servers run at 40hz, so stick to divisors of that:
40, 20 (default), 10.  A snaps of 40 will usually just cause
you to hit your rate limit a lot faster.  It may be usefull
for tuning rate, if nothing else.

You can adjust the local timing point with "cg_timenudge ",
which effectively adds local lag to try to make sure you interpolate
instead of extrapolate.  If you really want to play on a server that
is dropping a ton of packets, a timenudge of 100 or so might make
the game smoother.





4/26/99
-------
* converted cvar allocation to indexes to allow range checking
* cgame converted over to use vmCvar_t instead of cvar_t
	needed for interpreted cgame
* fixed server crashing string bug
* adjusted scoreboard for 8 players
* show hostname on connection screen
* fixed null model warning on startup
* more space for hostname on local servers screen
* fixed mac Open Transport memory buffer bug
	this was causing most of the mac crashes
* made Info_ValueForKey() case insensitive
* sv_privateClients, sv_privatePassword
	this allows you to reserve slots on a
	public server for password access while
	allowing most to be freely available
* "server is full" message on connect screen
* archive handicap in config file
* cheat protect r_nocurves
* byte order independent zip checksum
* removed cl_stereo, use glConfig.stereoEnabled



4/25/99
-------

Some people seem to think that I just make up these performance comparison
numbers.  I don't.  I measure things, and I understand control conditions.

In this discussion, assume "wintel" is a 500 mhz PIII with either a agp
rage128, or an agp TNT card, and "macos" is a 400 mhz G3 with the pci rage128.

At the highest level, you can make application class comparisons between
platforms.  For instance, CodeWarrior on the mac compiles faster than VC++
on wintel, but stuffit is way slower than winzip.  This is useful data,
but says more about the application design than the relative merits of the
platforms.  CW uses a single object file repository, for instance.

A better comparison is an identical app on both platforms.

Photoshop is often faster on macos than wintel.  There is certainly a lot
of common code, but individual filters are optimized for each platform.
Some of these hand optimized operations are significantly faster on the
mac.

Quake1 was the counterpoint to that.  Quake1 had significant amounts of
hand tuned asm code for intel, and the PPC version never got as much
attention.  The PPC version was noticeably slower (you would have to time
at 640*480 to avoid unfairly penalizing the mac for lac