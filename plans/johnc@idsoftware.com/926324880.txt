Welcome to id Software's Finger Service V1.5!

Name: John Carmack
Email: johnc@idsoftware.com
Description: Programmer
Project: Quake 3 Arena
Last Updated: 05/10/1999 05:06:22 (Central Standard Time)
-------------------------------------------------------------------------------

5/10/99
-------
A good day of work.  I just finished a long test game with all three
architectures, and everything looks solid.

As far as I can tell, these are ready to go after making installers
and such, but everyone else has an oportunity to find bugs while I
sleep...

We won't hold up for minor gameplay issues, but if anyone turns up
a repeatable crasher I will rebuild everything.

Barring problems, we should start rolling the releases out tonight.

* fixed crash case on fallback from an unsupported fullscreen
* fixed overrun with very fast system connecting to
	a very lagged server
* fixed bad Z_Free on sounds not found
* fixed autoswitch with sync clients
* fixed losing console field on positive histories
* fixed demo recording and playback with new net code
* handle signed bit fields in msg code
* fixed playerstate event bit loss on encoding
* fixed "bad clientnum on player entity"
* reenabled corpses sinking into ground


5/9/99
------
We would up making tweaks to both maps today, so the data didn't
reach final form until a few hours ago.

I just finished making release candidates for all three architectures,
but I already found a couple problems that need to be fixed.

If everything goes perfectly (ha), and I nail these problems immediately
when I wake up, then we might make it out tonight, but it is looking a
bit doubtful.


There are a few known issues that I decided NOT to hold the test up for:

The gauntlet is functioning correctly, but the visuals are wrong.
The designed behavior is that when you hold down attack it will scan
for a target and only punch forward when it hits.  The visuals currently
show it punching constantly.

Dynamic lighting is currently taking a really excessive amount of cpu
time.  If you are having performance problems in firefights, you may
want to turn it off.  The option is in the preferences, or you can
just issue "r_dynamicLighting 0" at the console.

The powerup item sounds aren't global across the entire world since
I went to the client side predicted items.

There are some cases when a weapon that was picked up with a predicted
item and immediately fired doesn't make a muzzle flash.


* fixed fs_copyfiles after ospath split
* fixed look-at-killer 
* changed railgun impact to plasma dish
* convert connect packet to infostring
* put footsteps back in...
* r_drawsun 0 by default to avoid probs for now
* fixed event clear overwrite problem
* client side predict weapon switch on item pickup
* changed sound fallbacks to "visor" from "male"
* made turbulent texcoords based off of xyz instead of st




5/8/99
------
There is one must-fix issue and a couple smaller issues
remaining before the release candidate build, then we
have to do a lot of testing on it.  I made a lot of
significant changes in the last week, and I'm sure there
are some things we still need to sort out before we
inflict it on the general public.

We are aiming for sunday, but understand that that means
sunday evening, not sunday morning.

If saturday night / sunday morning testing on the release
candidate turns up significant problems, we will put off
the release until they are fixed.  That could be later
sunday night, or it might not make it until monday night.

The previous release delays for win32 were issues out
of our control, but this release rests squarely on me.
The content and other issues are ready, but we still
need to make sure all the new code is solid.


* fixed give item bug
* new first snapshot timing
* moved sun drawing outside of sky shader to fix showtris
* r_drawSun
* handle all shader tesselations in q3map with tjunc fixups
* different flatness epsilons for edge vs border grids
* reorganize sound directories
* removed footsteps on non-metalic and non-water surfaces
* fixed bug with multiple looping sounds
* client side predict teleporters, go to "hyperspace"
* precache remaining liquid sounds
* don't fire jumppad events if upward velocity


5/7/99
------
* changed grabbed items to SVF_NOCLIENT instead of EF_NODRAW
	now that the pickup event is on the player
* clear event flags with event on reset
* move playerstate to netfield bit communication
* fixed configstring delta sequencing issue after initial
	gamestate
* extended the netgraph: short red lines are missing
	client to server packets (need to drop 3 in a row)
* extended cg_debugevents
* increased cl_maxpackets to 30
* fixed bug with console field not getting drawwidth set
* fastsky implies noportals
* changed fastsky color
* q3map now fixes tjunctions at fog boundaries
* build optimized tree with visible hulls of sides
* adjusted plane culling to avoid some cracks
* r_facePlaneCull
* fixed too-lax colinear collapse to avoid some cracks


5/5/99
------
* client side predict item pickups
	running over items was one of the few
	remaining locally perceived signs of lag
* new pont-in-patch test code
* fixed pathname errors when mac users had
	slashes in their paths: "B/W mac". sigh.


5/4/99
------
* seeded random numbers differently on tourney restarts
* fixed events on initial snapshots
* removed g_maxentities configuration, set by G_ENTITY_BITS
* cl_motd 0 to allow never sending request packets
* fixed map cache clearing bug
* cg_drawFPS 1 for running fps counter in corner
* remove all teleport destination pads
* moved checkmap out of cgame
* moved time positioning out of cgame
* made usercmd overrun freeze in place instead of snapping back
* slightly increased shotgun spread
* protected against using a cleared clientinfo
* use snapped origin from players for linking to prevent
	slight prediction errors during player collisions


4/30/99
-------
I put together a document on optimizing OpenGL drivers for Q3 that
should be helpfull to the various linux 3D teams.

http://www.quake3arena.com/news/glopt.html


4/30/99
-------
* vmtest framework, q3asm work
* converted scene building to procedural style
	allows better error checking, better
	performance characteristics when interpreted,
	and is a setup stage for SMP optimizations in
	the renderer if I get around to it
* protected some potential div by 0 areas in cgame


4/29/99
-------
* rework versioning for architecture tracking
* use a seperate endpoint for address resolves on mac
* hide OTLook warnings if "developer" isn't set
* defered mac renderer scanning until after mode set so
	8 bit desktops don't confuse it
* global motd/update server
* fixed view model animations on models with custom anims

technical note:

Q3 can run networked player movement in either an asynchronous or
synchronous manner.  The default mode is to allow all client movement to be
done asynchronously with the servers advancement of time.

The primary reason is to allow player movement to be predicted on the client
side.  The primary drawback is that while your movement is smooth, the other
players that you see running around in the world move with a jerkiness that
is relative to their framerate and network connection quality.  It is NOT
necessarily relative to their ping - a player on a fast system with a clean
modem connection can move smoothly.  If you see a player stuttering around,
either they have a bad franerate, or the network connection between them and
the server or you and the server is poor.  The amount of stuttering is sort
of the sum of the dropped or variable packets on BOTH connections.

You can force Q3 to run all clients synchronously by setting
"g_synchronousClients 1" on the server.  This will make Q3 behave similar to
Q1 for networking.  All movement will be lagged except view angles, which are
still short-circuited immediately.

Some people claim to prefer synchronous movement when everyone had a very
good ping, but I don't personally think it is ever a play benefit.  It
makes leading players a bit easier, but I think the crisp movement control
of client side prediction is a much better tradeoff.

However, there is still a reason for using it:  recorded demos come out a
LOT smoother looking when running with sync.  Note that q3test does not
allow demo recording and playback, so this is just for future reference...


4/28/99
-------
* converted sound positioning away from callback method
* increased mac memory zone by 5 megs
* new memory allocator for temporary render use during init
* converted cmodel references to handles and range checked
* converted sound references to handles and range checked
* converted file references to handles and range checked

4/27/99
-------
* cgame converted to use local buffer based lerpTag for interpretation
* cgame converted to use local buffer based argv for interpretation
* new sound code to remove latency 
* added drop shadow to field characters and fixed scrolling
* fixed edge-of-bounce-pad misprediction error (server side)
* remove broken weapon-stay dmflag
* made menu gfx never picmip
* cheat protect r_lightmap
* clear sound buffer before any file IO
* use GetOSEvent instead of WaitNextEvent on mac when fullscreen
	removes hitches caused by other tasks and gives a
	performance boost
* continuous scoreboard / ping update when tab is down
* put version number on menu background
* fixed toggle cvar bug
* dim out behind floating menus


4/26/99
-------

One more addition to net cvars:

"cl_maxpackets" will restrict the maximum number of outgoing
packets to prevent client to server rate problems.  This does
not limit the client framerate.  This defaults to 20, which
might actually be a bit low.  You might try experimenting
with raising this to 40.

"cl_maxfps" still exists, but it will never need to be used
for networking reasons.


4/26/99
-------

Interpreting the lagometer (the graph in the lower right corner):

The upper graph (blue/yellow) slides one pixel for every rendered
frame.  Blue lines below the baseline mean that the frame is
interpolating between two valid snapshots.  Yellow lines above
the baseline mean the frame is extrapolating beyond the latest
valid time.  The length of the line is proportional to the time.

The lower graph (green/yellow/red) slides one pixel for every
received snapshot.  By default, snapshots come 20 times a second,
so if you are running >20 fps, the top graph will move faster, and
vice versa.  A red bar means the snapshot was dropped by the
network.  Green and yellow bars are properly received snapshots,
with the height of the bar proportional to the ping.  A yellow
bar indicates that the previous snapshot was intentionally
supressed to stay under the rate limit.

The upper graph indicates the consistancy of your connection.
Ideally, you should always have blue bars of only a pixel or two
in height.  If you are commonly getting big triangles of yellow
on the graph, your connection is inconsistant.

In a heavy firefight, it is normal for modem players to see yellow
bars in the bottom graph, which should return to green when the
action quiets down.  If you are getting several red bars visible,
you may want to look for a server that drops less packets.

There are a few tuning variables for people trying to optimize
their connection:

The most important one is "rate", which is what the connection
speed option in the menu sets.

We are fairly conservative with the values we set for the given
modem speeds: 2500 for 28.8, 3000 for 33, and 3500 for 56k.

You may actually be connecting faster than that, and modem
compression may be buying you something, so you might get a
better play experience by increasing the values slightly.

If you connect at 50000 bps, try a rate of 5000, etc.

I err on the conservative side, because too low of a rate will
only make the movement of other things in the world choppy, while
too high of a rate can cause huge amounts of lag.

Note that the optimal rate will be somewhat lower than a rate
for QW or Q2, because I now include the UDP packet header
length in the bandwidth estimate.

You can ask for a different number of snapshots by changing the
"snaps" variable, but there isn't a lot of benefit to that.
Dedicated servers run at 40hz, so stick to divisors of that:
40, 20 (default), 10.  A snaps of 40 will usually just cause
you to hit your rate limit a lot faster.  It may be usefull
for tuning rate, if nothing else.

You can adjust the local timing point with "cg_timenudge ",
which effectively adds local lag to try to make sure you interpolate
instead of extrapolate.  If you really want to play on a server that
is dropping a ton of packets, a timenudge of 100 or so might make
the game smoother.





4/26/99
-------
* converted cvar allocation to indexes to allow range checking
* cgame converted over to use vmCvar_t instead of cvar_t
	needed for interpreted cgame
* fixed server crashing string bug
* adjusted scoreboard for 8 players
* show hostname on connection screen
* fixed null model warning on startup
* more space for hostname on local servers screen
* fixed mac Open Transport memory buffer bug
	this was causing most of the mac crashes
* made Info_ValueForKey() case insensitive
* sv_privateClients, sv_privatePassword
	this allows you to reserve slots on a
	public server for password access while
	allowing most to be freely available
* "server is full" message on connect screen
* archive handicap in config file
* cheat protect r_nocurves
* byte order independent zip checksum
* removed cl_stereo, use glConfig.stereoEnabled



4/25/99
-------

Some people seem to think that I just make up these performance comparison
numbers.  I don't.  I measure things, and I understand control conditions.

In this discussion, assume "wintel" is a 500 mhz PIII with either a agp
rage128, or an agp TNT card, and "macos" is a 400 mhz G3 with the pci rage128.

At the highest level, you can make application class comparisons between
platforms.  For instance, CodeWarrior on the mac compiles faster than VC++
on wintel, but stuffit is way slower than winzip.  This is useful data,
but says more about the application design than the relative merits of the
platforms.  CW uses a single object file repository, for instance.

A better comparison is an identical app on both platforms.

Photoshop is often faster on macos than wintel.  There is certainly a lot
of common code, but individual filters are optimized for each platform.
Some of these hand optimized operations are significantly faster on the
mac.

Quake1 was the counterpoint to that.  Quake1 had significant amounts of
hand tuned asm code for intel, and the PPC version never got as much
attention.  The PPC version was noticeably slower (you would have to time
at 640*480 to avoid unfairly penalizing the mac for lack of low res
modes).

So, clearly, hand tuned asm code can make either platform pull ahead.  It
also shows that the two platforms are at least fairly close in performance.
I never said macs were SLOW, just not quite as fast as the best intel systems.

Quake3 doesn't software rasterize, so there isn't any great place for lots
of asm code (the great place is in the OpenGL driver).  The code is
essentially identical on all platforms.

Q3 is definitely faster on a wintel system than a macos system.  When the
wintel version is released, everyone will be independantly repeating that
measurement.

Even this measurement isn't exactly an apples to apples comparison, because
the OpenGL driver and 3D card are still a significant variance.  The two
can be broken out farther:  Q3 can be run without 3D output to test just
the identical compiled code.  Wintel is still faster, although somewhat
less so.  The OpenGL + 3D card setup can be benchmarked separately on the
axis of throughput and fill rate, which show the intel system being
significantly faster.  I can't break that apart into the two separate
components, but I will guess that the OpenGL driver is probably as efficient
as the wintel drivers and the performance delta is due to the system
interface and the video card.  The current mac rage128 cards run at 75 mhz,
which is a third slower than the PC cards.  AGP is also more than just a
faster PCI, it can influence the structure of communication with the card.

It has been my observation in the past that most of my code tracks just about
midway between specint and specfp for performance comparisons.  There is a
lot of floating point, but it is all short vectors, rather than the massive
vectors of scientific computing.  If we discount the graphics subsystem, Q3
follows this reasonably well.  The intel system does slightly better than
projected.

"Sucks" is a subjective description that can be dismissed as opinion.  Note
that I have NEVER said that the hardware sucks, or the user interface sucks,
just that the mac OPERATING SYSTEM sucks.

"Faster", when qualified with testing conditions, is objective, and all the
wishing in the world doesn't change it.

Objectivity and quantification are the paths to improvement.  

I will be very happy if Apple can produce a desktop system that is faster
than anything else you can get.  I respect good engineering from any source.
Altivec should be better than the PIII extensions (trinary ops -- yeah!).
The upcoming system architectures look good.  They have a shot at it, but
they won't make it if they complacently think "oh, we are already faster
than any pc system".

My twin turbo F50 can still be outrun at the dragstrip by much cheaper
race cars.  Many ferrari owners would not dare set foot at a drag strip,
because they fear objective measurements that may not show their important
possession in the best light.  I would rather have the facts, so I can base
future decisions on logical grounds.


4/24/99
-------
We are finally closing in on the first release of Q3test.

As you have probably heard by now, the first release in going to be the mac
version, probably followed by the linux version, and only then the
windows version.

Some of you are busy getting all bent out of shape about this.

We want to get a lot of people playing with the test to find bugs and
offer well thought out suggestions, but there are classes of bugs and
suggestions that emerge in each order of magnitude of exposed testers.

If a given bug is going to show up when a thousand people have looked
at it, but we had released it to a hundred thousand people, then we are
going to have a lot of duplication to wade through.

The mac testers will find some obvious problems.
We will fix them.
The later releases will be better.

Even if we had the windows distribution ready to go right now, I wou