Welcome to id Software's Finger Service V1.4!

Name: John Carmack
Email: johnc@idsoftware.com
Description: Programmer
Project: Quake 2
Last Updated: 12/25/1997 15:21:24 (Central Standard Time)
-------------------------------------------------------------------------------

Dec 25:

We are going to release a new quake 2 executable that fixes the
malicious server crashing problems Real Soon Now.  It also fixes a
ton of other problems that have been reported, so we are going to
have to give it some good testing before releasing it.

John Cash has two kids that would lynch him if he came in and worked
on christmas, so we certainly won't be able to get a release candidate
together before the weekend.  I am fairly confidant we will have it
released to the public on sunday.

I have been spending most of my time on trinity research but I have
still made quite a few fixes to Q2.  John Cash has made many more (he
is just finishing up the IPX coding, among other things).

I have been doing a lot of testing over a proxy that gives me a very
bad ping (400 - 800), so I was able to find and fix two significant
errors with the prediction code.

The reason why you get a jerk when running forward and firing rockets,
blasters, or grenades is that the client side prediction code was
blocking you on your own missiles.

The jerky behavior on plats was due to a subtle error in the prediction
error interpolation.  A prediction error was causing oscillations as long
as your latency, instead of smoothing out over just 100 ms.  The plats
are now smooth as long as you aren't dropping packets, and other
mispredictions are also handled much better.

There are still a lot of other things that will be fixed in an upcoming
release, but this will definately be an executable worth grabbing.

My fixes:

* zombies aren't being removed properly
* joystick not in menu
* classname for rockets and bolts
* no screaming when invulnerable and in lava
* lowered water blend values
* clear powerups when dead (no more breather sounds)
* only play "computer updated" three times max
* mapname serverinfo now updated properly
* changed "rejected a connection" to "Server is full"
* made console "rejected a connection" a developer only message
* made WSAWOULDBLOCK warning silent
* max 10 packets/second during connection process
* set cl_maxfps to 90
* increased loading plaque timeout value to 120 seconds
* paused not default to 1
* no savegame in deathmatch
* fixed ; binding from menu
* no crouch when airborne
* removed half-baked $ macro expansion
* pause on landing before re-jump (fixes no fall damage bug)
* public server framework
* no ; comment in config files
* teleporter events
* lower hyperblaster damage
* don't use PORT_ANY for clients!
* fix the entity number thing here
* don't re-check CD after the first time
* auto cddir from cd scan
* dissallow kill from intermissions
* faster rockets
* less bfg effect damage
* remove packet command from client
* strip trailing spaces on cmd_args
* added protocol to serverinfo
* used CMD_BACKUP instead of UPDATE_BACKUP for phone jack
* don't predict clip into your own missiles
* good netgraph
* validate userinfo for semicolons and quotes
* don't copy savegames on dedicated servers
* also check current directory for game dll loading
* changed connect packet on client to differ from server
* bump protocol version
* fixed error interpolation on plats
* only respawn with attack or jump
* fov as a userinfo
* show weapon icon if fov > 90


------------------------------

Dec 23:

The DOOM source is up.

Merry christmas!


ftp://ftp.idsoftware.com/idstuff/source/doomsrc.zip

---------- contents of README.TXT --------------

Here it is, at long last.  The DOOM source code is released for your
non-profit use.  You still need real DOOM data to work with this code.
If you don't actually own a real copy of one of the DOOMs, you should
still be able to find them at software stores.

Many thanks to Bernd Kreimeier for taking the time to clean up the
project and make sure that it actually works.  Projects tends to rot if
you leave it alone for a few years, and it takes effort for someone to
deal with it again.

The bad news:  this code only compiles and runs on linux.  We couldn't
release the dos code because of a copyrighted sound library we used
(wow, was that a mistake -- I write my own sound code now), and I
honestly don't even know what happened to the port that microsoft did
to windows.

Still, the code is quite portable, and it should be straightforward to
bring it up on just about any platform.

I wrote this code a long, long time ago, and there are plenty of things
that seem downright silly in retrospect (using polar coordinates for
clipping comes to mind), but overall it should still be a usefull base
to experiment and build on.

The basic rendering concept -- horizontal and vertical lines of constant
Z with fixed light shading per band was dead-on, but the implementation
could be improved dramatically from the original code if it were
revisited.  The way the rendering proceded from walls to floors to
sprites could be collapsed into a single front-to-back walk of the bsp
tree to collect information, then draw all the contents of a subsector
on the way back up the tree.  It requires treating floors and ceilings
as polygons, rather than just the gaps between walls, and it requires
clipping sprite billboards into subsector fragments, but it would be
The Right Thing.

The movement and line of sight checking against the lines is one of the
bigger misses that I look back on.  It is messy code that had some
failure cases, and there was a vastly simpler (and faster) solution
sitting in front of my face.  I used the BSP tree for rendering things,
but I didn't realize at the time that it could also be used for
environment testing.  Replacing the line of sight test with a bsp line
clip would be pretty easy.  Sweeping volumes for movement gets a bit
tougher, and touches on many of the challenges faced in quake / quake2
with edge bevels on polyhedrons.

Some project ideas:

Port it to your favorite operating system.

Add some rendering features -- transparency, look up / down, slopes,
etc.

Add some game features -- weapons, jumping, ducking, flying, etc.

Create a packet server based internet game.

Create a client / server based internet game.

Do a 3D accelerated version.  On modern hardware (fast pentium + 3DFX)
you probably wouldn't even need to be clever -- you could just draw the
entire level and get reasonable speed.  With a touch of effort, it should
easily lock at 60 fps (well, there are some issues with DOOM's 35 hz
timebase...).  The biggest issues would probably be the non-power of two
texture sizes and the walls composed of multiple textures.


I don't have a real good guess at how many people are going to be
playing with this, but if significant projects are undertaken, it would
be cool to see a level of community cooperation.  I know that most early
projects are going to be rough hacks done in isolation, but I would be
very pleased to see a coordinated 'net release of an improved, backwards
compatable version of DOOM on multiple platforms next year.

Have fun.

John Carmack
12-23-97