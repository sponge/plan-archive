Welcome to id Software's Finger Service V1.5!

Name: John Carmack
Email: johnc@idsoftware.com
Description: Programmer
Project: Quake 3 Arena
Last Updated: 07/03/1999 18:15:49 (Central Standard Time)
-------------------------------------------------------------------------------
7/3/99
------

AMD K7 cpus are very fast.

Some timedemo numbers (a new demo, not comparable to previous scores):

Run at 640*480*16 bit color to emphasise the cpu/driver performance rather
than the hardware fill rate.

				K7-600	K7-550	PIII-500
TNT2 ultra 16 bit		73.9	68.5	53.8
Voodoo3 3000 16 bit		70.5	65.2	46.0

This is with K7 optimized drivers vs seperate PIII optimized drivers.

There is still wiggle room there in that it is possible that more effort
was expended to make the AMD drivers perform better.  That is perfectly
valid from a consumer's point of view, but muddies the technical CPU
comparison.

On identical code run on the systems, there was some more interesting data:

On my map processing tools, the K7 was faster than the PIII, but only
slightly more so than the reletive clock rate increase.  I would guess that
this is due to larger data sets that don't fit in cache as well.

On the matrox OpenGL drivers, which have not been optimized very much and
(to my knowledge) contain no PIII specific code, the K7 was a LOT faster.

The bottom line is that I feel comfortable standing behind the statement
that the K7 is faster than the PIII.  I will have to wait for some stuff
to come out of NDA to provide a more detailed technical analysis.

Architectural cleverness is all well and good, but if AMD can't keep the
clock speed up with intel, they will still fall behind.  A 700 mhz PIII
would probably find a lot of applications (especially integer apps) where
it would outperform a 600 mhz K7.


* stabilized cg_showfps
* added append support to module file opening
* automatic logging of game scores to games.log
* fixed guantlet firing action
* force a vid_restart on WM_DISPLAYCHANGE messages
* fixed sticking on stairs on very fast framerates
* fixed sticking on stair when jumping
* fixed sticking in corner while falling physics bug
* fixed slide down steep slope physics bug
* r_showimages texture use debugging tool
* cg_freezeDemo cvar
* cg_drawSnapshot cvar
* fixed warnings after demo playback
* changed "stopdemo" to "stoprecord"
* fixed phantom windows on task bar after exit
* check for unset player animation
* fixed the snap-down-look-up bug with very high sensitivities
* reduce inflicted damage by handicap
* all pmove results as events for proper demo playback

6/27/99
-------

For the past couple years when talking to chip makers about new 3D features,
3D texture maps would always come up, and I would have to mutter something
like:  "I think it is a good thing, but I can't give you a really awesome
example of using it.  3D Noise functions.  Stuff like that."

I have the awesome example now:  Lighting.

Through the entire development of Q3, I have been wanting to do dynamic
lighting of the world differently.  Many of the efficiencies gained by Q3's
new map format result in larger and larger lightmaps while it reduces polygon
count.  That meant that even small dynamic lights may force a lot of work to
generate new lighting textures.

I had been wanting to find a way to trade off additional rendering passes for
less CPU time.

This is a perfect example of me outthinking myself.

I knew it would have to be something with projecting a light spot texture
onto the world geometry, but I am keenly enough aware of the issues and
limitations in projecting a 2D texture onto 3D geometry that my mind kept
looking at worst case scenarios -- how do you project a continuous texture
onto the inside of a dome with the proper intensities, and some situations
with curves.  I thought it would require some non-trivial per triangle
analysis and operations, when I really just wanted something that could be
done on a per-vertex level.

Recently, the 3D texture insight hit me.

Create a 3D texture of, say, 32*32*32 texels and fill it with your light
attenuation function, bright point in the center, fading off to black at the
edge.  Set it to clamp mode, so any values beyond the edges stay black.  Set
up a texture coordinate generation matrix to position the light relative to
your models.  Its a simple translate and scale.  Set up lighting calculation
to only generate a value based on the relative angles, ignoring attenuation.
Use the resulting modulated texture mapping as your "lightmap" to modulate
another texture pass, or add to a previous lighting pass.

This has several important benefits:

It looks good (and identical) on both small and large polygons.  Vertex based
lighting needs an appalling amount of tessellation to avoid visibly
triangulation artifacts.  Even if you tessellate to the same sample density as
your lightmap grid (hundreds of thousands per map), vertex lighting still
looks worse, because it is a triangular instead of bilinear interpolation.

It can be done completely by upcoming lighting and texgen hardware, but is
efficient in software implementations.

It can be shadowed by either stencil volume shadows or shadow buffer tests.

Post Q3A, I plan on doing a research engine that is fully dynamically lit
and shadowed instead of using lightmaps.

Ok, but we don't have 3D textures in any hardware now, so this doesn't help
me for Q3A.

I continued thinking along complex lines, like "Any planar slice of a
spherical 3D texture will be a 2D circle, and the three triangle points
can occupy any location on their respective rings".

It still looked like a big mess.

I got tired of thinking about it, and just started coding in some
infrastructure to do extra lighting passes.  I just made a gradient circle
texture for the lighting, and generated the texture coordinates by just
translating and scaling X and Y from the world coordinates.

I got it running, grabbed a rocket launcher, and fired down a hallway.  It
looked just fine.  I was stunned.  I had been thinking about complex
ramifications of weird edge cases for the past year when all it took was a
couple hours of programming and the simplest possible approach to make it
work decent.  Sigh. :-)

The only real addition required was a fading of the light contribution with
Z distance from the surface.  The downside to this hack is that while you
get a nice ball of light moving over floors and ceilings, you only get a
wash of light on walls.  In hindsight, I can analyze this in the context of
our games and say "Almost all movement and targeting takes place in the XY
plane in a FPS, so accuracy along the Z axis is not necessary."

The somewhat more obvious change to dynamic lighting that wasn't related to
the projection issue is that I have it currently set up as a postprocess
pass, rather than an additive pass on the lightmap.  Adding to the lightmap
is more "right", but it really complicates the multitexture implementation,
and on some surfaces, the lightmap is actually done after the base texture,
so it couldn't be added to.  The end result is that brighter areas are
changed more by dlights than dark areas.  I don't feel TOO bad about that,
because its not like the dlight is much of a proper lighting simulation
even in the best case...


* fixed tourney restart
* fixed jittering on plats
* fixed ref use without a world
* new default image that lets you see mapping coordinates
* fixed reliable sequences on restarts and demos
* allow maxclients to change between levels
* randomize shell ejection start position and angles
* display attackers head after every wound
* added gamma and overbright support to mac version
* removed table from sound mixing
* remove smoke and blood puffs when you run through them
* set cheats to 1 on disconnect
* shader sort value is now floating point
* new trajectory type "TR_INTERPOLATE", skip interpoaltion
	for other types
* fixed door open timing
* fixed bug with >8 portal areas
* added area print to r_shwocluster
* removed all the parti